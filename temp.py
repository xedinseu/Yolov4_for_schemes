# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'diplom.ui'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt5 import QtCore, QtGui, QtWidgets
import os

class Ui_MainWindow(object):
    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(800, 600)
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")
        self.label = QtWidgets.QLabel(self.centralwidget)
        self.label.setGeometry(QtCore.QRect(10, 10, 481, 31))
        font = QtGui.QFont()
        font.setFamily("Arial")
        font.setPointSize(16)
        self.label.setFont(font)
        self.label.setObjectName("label")
        MainWindow.setCentralWidget(self.centralwidget)
        self.statusbar = QtWidgets.QStatusBar(MainWindow)
        self.statusbar.setObjectName("statusbar")
        MainWindow.setStatusBar(self.statusbar)

        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)

    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "Построение таблицы связей между элементами на схеме"))
        self.label.setText(_translate("MainWindow", "Подождите, идет подготовка нейросети к работе"))




import sys
app = QtWidgets.QApplication(sys.argv)
MainWindow = QtWidgets.QMainWindow()
ui = Ui_MainWindow()
ui.setupUi(MainWindow)
MainWindow.show()

os.system('''
cd cfg
sed -i 's/batch=64/batch=1/' yolov4-obj.cfg
sed -i 's/subdivisions=32/subdivisions=1/' yolov4-obj.cfg
sed -i 's/width=640/width=1280/' yolov4-obj.cfg
sed -i 's/#height=640/#height=1280/' yolov4-obj.cfg
cd ..
''')

file = QtWidgets.QFileDialog.getOpenFileName()[0]

print(file)

ui.label.setText("Идет обработка изображения")

f = open('images.txt','w')
f.write(file)
f.close()

os.system('./darknet detector test data/obj.data cfg/yolov4-obj.cfg yolov4-obj_last.weights -dont_show -ext_output -thresh 0.1 < /content/images.txt > result.txt')

imShow('predictions.jpg')

f = open('classes.txt', 'r')
classes = {}
k=0
for line in f:
  classes[line[:-1]] = k
  k+=1
f.close()
classes

def remove_values_from_list(the_list, val):
   return [value for value in the_list if value != val]

f = open('result.txt', 'r')
k=0
# служебная информация прокрутиться при открытом файле trash
f1 = open('trash.txt', 'w')
for line in f:
  # как только находим название файла, открываем соответствующий ему текстовый файл на запись, закрыв предыдущий
  if line.find('/content/')!= -1:
    f1.close()
    f1 = open('scheme_{}.txt'.format(k), 'w')
    k+=1
  # начинаем построчно парсить результаты, записывая их построчно в файл для очередной схемы
  one_obj_list = ''
  string = line.split(' ') # преврящаем очередную строку в список
  # удаляем из списка все пробелы и пустые значения, чтобы очтались только цифры и слова
  string = remove_values_from_list(string, ' ')
  string = remove_values_from_list(string, '')
  if string[0][:-1] in classes.keys(): # если первое значение списка есть в нашем словаре
  # то вычленяем из списка 4 значения для баундинг бокса и приводим их в нужный формат
    one_obj_list = one_obj_list + str(classes[string[0][:-1]]) + ' '
    one_obj_list = one_obj_list + str(int(string[2])/1280 + int(string[6])/1280/2) + ' '
    one_obj_list = one_obj_list + str(int(string[4])/1280 + int(string[8][:-2])/1280/2) + ' '
    one_obj_list = one_obj_list + str(int(string[6])/1280) + ' '
    one_obj_list = one_obj_list + str(int(string[8][:-2])/1280) + '\n'
    f1.write(one_obj_list)
f1.close()

import torchvision.ops.boxes as bops
import torch

def check_intersection(input1, input2):
  xy1 = input1[:2] # Получаем координаты x,y центра 
  wh1 = input1[2:4] # Получаем значения высоты и ширины
  wh_half1 = [x/2. for x in wh1] # Делим значения высоты и ширины пополам
  top_left1 = [x-y for x, y in zip(xy1, wh_half1)] # Получаем значение, соответствующее верхнему левому углу
  right_bottom1 = [x+y for x, y in zip(xy1, wh_half1)] # Получаем значение, соотвествующее правому нижнему углу

  rect1 = [top_left1[0],top_left1[1],right_bottom1[0],right_bottom1[1]]
          
  xy2 = input2[:2] # Получаем координаты x,y центра 
  wh2 = input2[2:4] # Получаем значения высоты и ширины
  wh_half2 = [x/2. for x in wh2] # Делим значения высоты и ширины пополам
  top_left2 = [x-y for x, y in zip(xy2, wh_half2)] # Получаем значение, соответствующее верхнему левому углу
  right_bottom2 = [x+y for x, y in zip(xy2, wh_half2)] # Получаем значение, соотвествующее правому нижнему углу

  rect2 = [top_left2[0],top_left2[1],right_bottom2[0],right_bottom2[1]]

  box1 = torch.tensor([rect1], dtype=torch.float)
  box2 = torch.tensor([rect2], dtype=torch.float)
  iou = bops.box_iou(box1, box2)

  return (float(iou))

# извлекаем из текстового документа данные в массив
f = open('scheme_0.txt', 'r')
big_list = []
iou_list = []
for line in f:
  a = line
  my_list = []
  for i in range(5):
    place = a.find(' ')
    a_1 = a[:place]
    a = a[place+1:]
    my_list.append(float(a_1))
  big_list.append(my_list)
# проходимся по всем элементам массива, ищем пересечения
for i in range(len(big_list)):
    for j in range(len(big_list)):
      if check_intersection(big_list[i][1:5],big_list[j][1:5]) !=0 and check_intersection(big_list[i][1:5],big_list[j][1:5]) !=1 and i!=j :
        iou_list.append([i,j])
komponents = [] # заносим в массив все компоненты и точки соединения связей
for i in range(len(big_list)):
  if big_list[i][0]!= 7.0:
    komponents.append(i)
# извлекаем список связей между komponents
fin_links = []
for komponent in komponents:
  links = [komponent]
  done_all = False
  while done_all == False:
    link = komponent
    done = False
    while done == False:
      for i in range(len(iou_list)):
        if iou_list[i][0] == link and (iou_list[i][1] not in links):
          link = iou_list[i][1]
          links.append(link)
          if link in komponents:
            fin_links.append([komponent,link])
            done = True
          break
        elif i == len(iou_list)-1:
          done = True
          done_all = True
# чистим список от повторов
for i in range(len(fin_links)):
  for j in range(len(fin_links)-1):
    if i!=j:
      if fin_links[i][0] == fin_links[j][1] and fin_links[i][1] == fin_links[j][0]:
        fin_links[i] = [-1,-1]
fin_links = list(filter(lambda a: a != [-1,-1], fin_links))
import pandas as pd 

file = '/root/OC dir/'

pd.DataFrame(fin_links).to_csv(file + "fin_links.csv")

sys.exit(app.exec_())
